# RemoteJuggler GitLab CI/CD Pipeline
# Builds Chapel binaries for multiple platforms and publishes releases

stages:
  - build
  - test
  - docs
  - package
  - sign
  - release
  - cache
  - sync

variables:
  CHAPEL_VERSION: "2.7.0"
  PROJECT_NAME: "remote-juggler"
  # Disable shallow clones for better caching
  GIT_DEPTH: 0

# Cache Mason dependencies
.mason_cache: &mason_cache
  cache:
    key: mason-${CI_COMMIT_REF_SLUG}
    paths:
      - .mason/
      - Mason.lock

# =============================================================================
# Build Stage
# =============================================================================

build:linux-amd64:
  stage: build
  image: chapel/chapel:${CHAPEL_VERSION}
  <<: *mason_cache
  script:
    - mason build --release
    - mv target/release/remote_juggler ${PROJECT_NAME}-linux-amd64
    - chmod +x ${PROJECT_NAME}-linux-amd64
    # Verify binary
    - ./${PROJECT_NAME}-linux-amd64 --version || echo "Binary built (version flag may not be implemented)"
  artifacts:
    name: "${PROJECT_NAME}-linux-amd64-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${PROJECT_NAME}-linux-amd64
    expire_in: 1 week

build:linux-arm64:
  stage: build
  image: chapel/chapel:${CHAPEL_VERSION}
  tags:
    - arm64
    - docker  # Force Docker executor (Chapel image requires Docker)
  <<: *mason_cache
  script:
    - mason build --release
    - mv target/release/remote_juggler ${PROJECT_NAME}-linux-arm64
    - chmod +x ${PROJECT_NAME}-linux-arm64
  artifacts:
    name: "${PROJECT_NAME}-linux-arm64-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${PROJECT_NAME}-linux-arm64
    expire_in: 1 week
  allow_failure: true  # arm64 runners may not be available

build:darwin-arm64:
  stage: build
  tags:
    - macos
    - arm64
    - shell  # Force native shell executor (Chapel/Homebrew not available in Docker)
  variables:
    GIT_STRATEGY: clone  # Force fresh clone after project rename
  <<: *mason_cache
  script:
    # Add Homebrew to PATH for shell executor
    - export PATH="/opt/homebrew/bin:$PATH"
    # Ensure Chapel is available (installed via Homebrew or similar)
    - which chpl || brew install chapel
    # Use Makefile instead of Mason to work around Mason 0.2.0 linking bug
    # (Mason can't handle "-framework Security" - splits on space)
    - make release
    - mv target/release/remote_juggler ${PROJECT_NAME}-darwin-arm64
    - chmod +x ${PROJECT_NAME}-darwin-arm64
    # Sign binary for macOS (if certificate available)
    - |
      if command -v codesign &> /dev/null && [ -n "$MACOS_SIGNING_IDENTITY" ]; then
        codesign --sign "$MACOS_SIGNING_IDENTITY" --options runtime ${PROJECT_NAME}-darwin-arm64
      fi
  artifacts:
    name: "${PROJECT_NAME}-darwin-arm64-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${PROJECT_NAME}-darwin-arm64
    expire_in: 1 week


# =============================================================================
# Tray App Build Stage
# =============================================================================

build:tray-darwin:
  stage: build
  tags:
    - macos
    - arm64
    - shell  # Force native shell executor (Swift not available in Docker)
  script:
    - cd tray/darwin
    - swift build -c release
    - mv .build/release/RemoteJugglerTray ../../${PROJECT_NAME}-tray-darwin-arm64
    - chmod +x ../../${PROJECT_NAME}-tray-darwin-arm64
  artifacts:
    name: "${PROJECT_NAME}-tray-darwin-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${PROJECT_NAME}-tray-darwin-arm64
    expire_in: 1 week
  allow_failure: true

build:tray-linux:
  stage: build
  image: golang:1.21-alpine
  script:
    - apk add --no-cache build-base gtk+3.0-dev
    - cd tray/linux
    - go mod download
    - CGO_ENABLED=0 go build -ldflags "-s -w" -o ../../${PROJECT_NAME}-tray-linux-amd64 .
    - chmod +x ../../${PROJECT_NAME}-tray-linux-amd64
  artifacts:
    name: "${PROJECT_NAME}-tray-linux-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${PROJECT_NAME}-tray-linux-amd64
    expire_in: 1 week
  allow_failure: true

# =============================================================================
# GTK GUI Build Stage (Rust + Libadwaita)
# =============================================================================

build:gtk-gui-linux:
  stage: build
  image: rust:latest
  timeout: 90 minutes
  cache:
    key: gtk-gui-cargo-${CI_COMMIT_REF_SLUG}
    paths:
      - gtk-gui/target/
      - /usr/local/cargo/registry/
      - /usr/local/cargo/git/
  before_script:
    - apt-get update
    - apt-get install -y libgtk-4-dev libadwaita-1-dev pkg-config
  script:
    - cd gtk-gui
    - cargo build --release
    - strip target/release/remote-juggler-gui
    - mv target/release/remote-juggler-gui ../${PROJECT_NAME}-gui-linux-amd64
    - chmod +x ../${PROJECT_NAME}-gui-linux-amd64
  artifacts:
    name: "${PROJECT_NAME}-gui-linux-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${PROJECT_NAME}-gui-linux-amd64
    expire_in: 1 week

test:gtk-gui:
  stage: test
  image: rust:latest
  before_script:
    - apt-get update
    - apt-get install -y libgtk-4-dev libadwaita-1-dev pkg-config xvfb at-spi2-core dbus-x11
  script:
    - cd gtk-gui
    # Start D-Bus
    - eval $(dbus-launch --sh-syntax)
    # Start Xvfb for headless GTK tests
    - export DISPLAY=:99
    - Xvfb :99 -screen 0 1280x1024x24 &
    - sleep 3
    # Run all tests (unit + proptest)
    - cargo test --all-features -- --test-threads=1
  artifacts:
    reports:
      junit: gtk-gui/test-results.xml
    when: always
  allow_failure: true

test:gtk-gui-integration:
  stage: test
  image: rust:latest
  before_script:
    - apt-get update
    - apt-get install -y libgtk-4-dev libadwaita-1-dev pkg-config xvfb at-spi2-core dbus-x11
  script:
    - cd gtk-gui
    # Run integration tests (config parsing, security modes)
    - cargo test --test integration_test
    # Run UI tests with Xvfb
    - eval $(dbus-launch --sh-syntax)
    - export DISPLAY=:99
    - Xvfb :99 -screen 0 1280x1024x24 &
    - sleep 3
    - cargo test --test integration_test -- --include-ignored --test-threads=1
  allow_failure: true

test:tray-linux:
  stage: test
  image: golang:1.21
  script:
    - cd tray/linux
    - go test -v ./...
  allow_failure: true

test:tray-darwin:
  stage: test
  tags:
    - macos
    - arm64
    - shell
  script:
    - cd tray/darwin
    - swift test
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH
      when: manual

test:gtk-gui-lint:
  stage: test
  image: rust:latest
  before_script:
    - apt-get update
    - apt-get install -y libgtk-4-dev libadwaita-1-dev pkg-config
    - rustup component add clippy rustfmt
  script:
    - cd gtk-gui
    - cargo fmt --check
    - cargo clippy --all-targets --all-features -- -D warnings
  allow_failure: true

package:gtk-gui-appimage:
  stage: package
  image: ubuntu:22.04
  needs:
    - build:gtk-gui-linux
  before_script:
    - apt-get update
    - apt-get install -y wget file fuse libfuse2 desktop-file-utils
  script:
    - export VERSION="${CI_COMMIT_TAG:-0.0.0}"
    # Create AppDir structure
    - mkdir -p AppDir/usr/bin AppDir/usr/share/applications AppDir/usr/share/icons/hicolor/scalable/apps AppDir/usr/share/metainfo
    - cp ${PROJECT_NAME}-gui-linux-amd64 AppDir/usr/bin/remote-juggler-gui
    - chmod +x AppDir/usr/bin/remote-juggler-gui
    - cp gtk-gui/data/dev.tinyland.RemoteJuggler.desktop AppDir/usr/share/applications/
    - cp gtk-gui/data/dev.tinyland.RemoteJuggler.desktop AppDir/
    - cp gtk-gui/data/dev.tinyland.RemoteJuggler.metainfo.xml AppDir/usr/share/metainfo/
    # Create placeholder icon
    - |
      cat > AppDir/usr/share/icons/hicolor/scalable/apps/dev.tinyland.RemoteJuggler.svg << 'EOF'
      <svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
        <rect width="256" height="256" rx="32" fill="#3584e4"/>
        <text x="128" y="160" font-family="system-ui" font-size="120" font-weight="bold" fill="white" text-anchor="middle">RJ</text>
      </svg>
      EOF
    - ln -sf usr/share/icons/hicolor/scalable/apps/dev.tinyland.RemoteJuggler.svg AppDir/dev.tinyland.RemoteJuggler.svg
    - ln -sf dev.tinyland.RemoteJuggler.svg AppDir/.DirIcon
    # Create AppRun
    - |
      cat > AppDir/AppRun << 'APPRUN'
      #!/bin/bash
      SELF=$(readlink -f "$0")
      HERE=${SELF%/*}
      export PATH="${HERE}/usr/bin:${PATH}"
      export LD_LIBRARY_PATH="${HERE}/usr/lib:${LD_LIBRARY_PATH}"
      export XDG_DATA_DIRS="${HERE}/usr/share:${XDG_DATA_DIRS}"
      exec "${HERE}/usr/bin/remote-juggler-gui" "$@"
      APPRUN
    - chmod +x AppDir/AppRun
    # Download appimagetool
    - wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
    - chmod +x appimagetool-x86_64.AppImage
    - ARCH=x86_64 ./appimagetool-x86_64.AppImage AppDir ${PROJECT_NAME}-gui-${VERSION}-x86_64.AppImage
  artifacts:
    paths:
      - "*.AppImage"
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG
  allow_failure: true

# =============================================================================
# Test Stage
# =============================================================================

test:unit:
  stage: test
  image: chapel/chapel:${CHAPEL_VERSION}
  <<: *mason_cache
  needs: []  # Run immediately, don't wait for build stage
  script:
    # Add Mason registry for QuickChpl
    - |
      mkdir -p ~/.mason/registry
      cat > ~/.mason/registry/mason-registry.toml << 'EOF'
      [[registry]]
      name = "tinyland"
      source = "https://github.com/Jesssullivan/mason-registry"
      branch = "sid"
      EOF
    # Fetch dependencies including QuickChpl
    - mason update || true
    # Run unit tests
    - chmod +x scripts/run-tests.sh
    - ./scripts/run-tests.sh
  artifacts:
    reports:
      junit: test-results.xml
    paths:
      - test-results.xml
    when: always

test:chplcheck:
  stage: test
  image: chapel/chapel:${CHAPEL_VERSION}
  needs: []  # Run immediately, don't wait for build stage
  script:
    # Run chplcheck linter on all Chapel source files
    - |
      echo "Running chplcheck linter..."
      find src -name "*.chpl" -exec chplcheck {} \; 2>&1 | tee chplcheck-report.txt
      # Check for errors (warnings are allowed)
      if grep -q "error:" chplcheck-report.txt; then
        echo "chplcheck found errors"
        exit 1
      fi
  artifacts:
    paths:
      - chplcheck-report.txt
    when: always
  allow_failure: false

test:lint:
  stage: test
  image: chapel/chapel:${CHAPEL_VERSION}
  needs: []  # Run immediately, don't wait for build stage
  script:
    # Verify code compiles without errors
    - mason build
  allow_failure: true

test:mcp-compliance:
  stage: test
  image: chapel/chapel:${CHAPEL_VERSION}
  needs:
    - build:linux-amd64
  script:
    - chmod +x ${PROJECT_NAME}-linux-amd64
    # Test MCP initialization
    - |
      echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-11-25","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}' | \
        timeout 5 ./${PROJECT_NAME}-linux-amd64 --mode=mcp || true
    # Run protocol compliance script if available
    - |
      if [ -f scripts/test-mcp-protocol.sh ]; then
        chmod +x scripts/test-mcp-protocol.sh
        ./scripts/test-mcp-protocol.sh
      fi
  allow_failure: true

test:integration:
  stage: test
  image: chapel/chapel:${CHAPEL_VERSION}
  needs:
    - build:linux-amd64
  script:
    - chmod +x ${PROJECT_NAME}-linux-amd64
    # Test basic CLI commands
    - ./${PROJECT_NAME}-linux-amd64 --help || echo "Help flag may not be implemented"
    - ./${PROJECT_NAME}-linux-amd64 list || echo "List command test"
  allow_failure: true

# =============================================================================
# HSM C Library Tests
# =============================================================================

test:hsm-unit:
  stage: test
  image: ubuntu:24.04
  needs: []  # Run immediately, don't wait for build stage
  before_script:
    - apt-get update
    - apt-get install -y build-essential
  script:
    - cd pinentry
    - make test
  artifacts:
    paths:
      - pinentry/test_hsm
    when: always

test:hsm-integration:
  stage: test
  image: ubuntu:24.04
  needs:
    - test:hsm-unit
  before_script:
    - apt-get update
    - apt-get install -y build-essential python3 gnupg gpg-agent
  script:
    - cd pinentry
    - make all
    - chmod +x test_hsm_integration.sh
    - ./test_hsm_integration.sh --verbose
  allow_failure: true  # Some tests require hardware (GPG agent, HSM)

test:hsm-tpm-mock:
  stage: test
  image: ubuntu:24.04
  tags:
    - tpm-available
  before_script:
    - apt-get update
    - apt-get install -y build-essential libtss2-dev libtss2-esys-dev swtpm swtpm-tools tpm2-tools
  script:
    - |
      # Start software TPM emulator
      mkdir -p /tmp/swtpm
      swtpm socket --tpmstate dir=/tmp/swtpm --tpm2 --ctrl type=tcp,port=2322 --server type=tcp,port=2321 &
      sleep 2
      export TPM2TOOLS_TCTI="swtpm:host=127.0.0.1,port=2321"
      # Build and test with TPM support
      cd pinentry
      make test
  allow_failure: true  # TPM runners may not be available
  rules:
    - if: $CI_COMMIT_BRANCH
      when: manual

# =============================================================================
# E2E Test Stage (pytest)
# =============================================================================

test:e2e:
  stage: test
  image: python:3.12-slim
  needs:
    - build:linux-amd64
  before_script:
    - apt-get update
    - apt-get install -y git gnupg gpg-agent
    - pip install -r test/e2e/requirements.txt
  script:
    - chmod +x ${PROJECT_NAME}-linux-amd64
    - export REMOTE_JUGGLER_BIN="$(pwd)/${PROJECT_NAME}-linux-amd64"
    - pytest test/e2e/ -v --tb=short -m "not tpm and not secure_enclave and not yubikey and not hardware"
  artifacts:
    reports:
      junit: pytest-results.xml
    when: always

test:e2e-installation:
  stage: test
  image: python:3.12-slim
  needs:
    - build:linux-amd64
  before_script:
    - apt-get update
    - apt-get install -y git gnupg gpg-agent
    - pip install -r test/e2e/requirements.txt
  script:
    - chmod +x ${PROJECT_NAME}-linux-amd64
    - export REMOTE_JUGGLER_BIN="$(pwd)/${PROJECT_NAME}-linux-amd64"
    - pytest test/e2e/test_installation.py -v --tb=short
  artifacts:
    reports:
      junit: pytest-installation-results.xml
    when: always

test:e2e-gpg:
  stage: test
  image: python:3.12-slim
  needs:
    - build:linux-amd64
  before_script:
    - apt-get update
    - apt-get install -y git gnupg gpg-agent
    - pip install -r test/e2e/requirements.txt
  script:
    - chmod +x ${PROJECT_NAME}-linux-amd64
    - export REMOTE_JUGGLER_BIN="$(pwd)/${PROJECT_NAME}-linux-amd64"
    - pytest test/e2e/ -v --tb=short -m gpg
  artifacts:
    reports:
      junit: pytest-gpg-results.xml
    when: always
  allow_failure: true

test:e2e-tpm:
  stage: test
  image: ubuntu:24.04
  needs:
    - build:linux-amd64
  services:
    - name: registry.gitlab.com/tinyland/projects/remote-juggler/swtpm:latest
      alias: swtpm
  before_script:
    - apt-get update
    - apt-get install -y python3 python3-pip python3-venv git gnupg gpg-agent tpm2-tools libtss2-tcti-swtpm0
    - python3 -m venv /venv
    - /venv/bin/pip install -r test/e2e/requirements.txt
  variables:
    TPM2TOOLS_TCTI: "swtpm:host=swtpm,port=2321"
  script:
    - chmod +x ${PROJECT_NAME}-linux-amd64
    - export REMOTE_JUGGLER_BIN="$(pwd)/${PROJECT_NAME}-linux-amd64"
    # Wait for swtpm service
    - |
      for i in $(seq 1 30); do
        if tpm2_getcap properties-fixed > /dev/null 2>&1; then
          echo "swtpm is ready"
          break
        fi
        echo "Waiting for swtpm... ($i/30)"
        sleep 1
      done
    - /venv/bin/pytest test/e2e/ -v --tb=short -m tpm
  artifacts:
    reports:
      junit: pytest-tpm-results.xml
    when: always
  allow_failure: true
  rules:
    # Run automatically on main/dev branches and tags
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "dev"
      when: on_success
    - if: $CI_COMMIT_TAG
      when: on_success
    # Run automatically on merge requests
    - if: $CI_MERGE_REQUEST_IID
      when: on_success
    # Manual trigger for other branches
    - if: $CI_COMMIT_BRANCH
      when: manual

test:e2e-mcp:
  stage: test
  image: python:3.12-slim
  needs:
    - build:linux-amd64
  before_script:
    - apt-get update
    - apt-get install -y git
    - pip install -r test/e2e/requirements.txt
  script:
    - chmod +x ${PROJECT_NAME}-linux-amd64
    - export REMOTE_JUGGLER_BIN="$(pwd)/${PROJECT_NAME}-linux-amd64"
    - pytest test/e2e/test_mcp_protocol.py -v --tb=short
  artifacts:
    reports:
      junit: pytest-mcp-results.xml
    when: always

# =============================================================================
# Security Scanning (inherited from template)
# =============================================================================

# =============================================================================
# Docker Image Builds
# =============================================================================

build:swtpm-image:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_TAG: ${CI_REGISTRY_IMAGE}/swtpm:${CI_COMMIT_SHORT_SHA}
    IMAGE_LATEST: ${CI_REGISTRY_IMAGE}/swtpm:latest
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $IMAGE_TAG -t $IMAGE_LATEST ci/docker/swtpm/
    - docker push $IMAGE_TAG
    - docker push $IMAGE_LATEST
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      changes:
        - ci/docker/swtpm/**/*
    - if: $CI_PIPELINE_SOURCE == "schedule"
  allow_failure: true

include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml
  - local: 'ci/gitlab-nix.yml'

sast:
  stage: test

secret_detection:
  stage: test

# =============================================================================
# Release Stage
# =============================================================================

release:package:
  stage: release
  image: curlimages/curl:latest
  needs:
    - build:linux-amd64
    - build:darwin-arm64
    - job: build:gtk-gui-linux
      optional: true
    - job: build:tray-darwin
      optional: true
    - job: build:tray-linux
      optional: true
    - job: package:rpm
      optional: true
    - job: package:deb
      optional: true
    - job: package:pacman
      optional: true
    - job: package:gtk-gui-appimage
      optional: true
    - job: sign:darwin-pkg
      optional: true
    - job: release:dmg
      optional: true
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - |
      # Upload each binary to GitLab Package Registry
      for binary in ${PROJECT_NAME}-*; do
        if [ -f "$binary" ]; then
          echo "Uploading $binary..."
          curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
            --upload-file "$binary" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${binary}"
        fi
      done
    - |
      # Upload FPM packages (RPM, DEB, Pacman)
      for pkg in *.rpm *.deb *.pkg.tar.zst; do
        if [ -f "$pkg" ]; then
          echo "Uploading $pkg..."
          curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
            --upload-file "$pkg" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${pkg}"
        fi
      done
    - |
      # Upload signed macOS PKG installers
      for pkg in *.pkg; do
        if [ -f "$pkg" ]; then
          echo "Uploading $pkg..."
          curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
            --upload-file "$pkg" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${pkg}"
        fi
      done
    - |
      # Upload DMG installers
      for dmg in *.dmg; do
        if [ -f "$dmg" ]; then
          echo "Uploading $dmg..."
          curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
            --upload-file "$dmg" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${dmg}"
        fi
      done
    - |
      # Upload GTK GUI binaries and AppImages
      for gui in ${PROJECT_NAME}-gui-*; do
        if [ -f "$gui" ]; then
          echo "Uploading $gui..."
          curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
            --upload-file "$gui" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${gui}"
        fi
      done
    - |
      # Upload AppImages
      for appimage in *.AppImage; do
        if [ -f "$appimage" ]; then
          echo "Uploading $appimage..."
          curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
            --upload-file "$appimage" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${appimage}"
        fi
      done
    - |
      # Upload checksums
      for sha in *.sha256; do
        if [ -f "$sha" ]; then
          echo "Uploading $sha..."
          curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
            --upload-file "$sha" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${sha}"
        fi
      done

release:gitlab:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - release:package
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - echo "Creating GitLab release for ${CI_COMMIT_TAG}"
  release:
    tag_name: $CI_COMMIT_TAG
    name: "RemoteJuggler ${CI_COMMIT_TAG}"
    description: |
      ## RemoteJuggler ${CI_COMMIT_TAG}

      Multi-provider git identity management tool with MCP/ACP support.

      ### Installation

      ```bash
      curl -fsSL https://gitlab.com/tinyland/projects/remote-juggler/-/raw/main/install.sh | bash
      ```

      ### Downloads

      **Binaries:**
      - [Linux AMD64](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-linux-amd64)
      - [Linux ARM64](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-linux-arm64)
      - [macOS ARM64](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-darwin-arm64)

      **Packages:**
      - [RPM (RHEL/Fedora/CentOS)](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/remote-juggler-${CI_COMMIT_TAG}-1.x86_64.rpm)
      - [DEB (Debian/Ubuntu)](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/remote-juggler_${CI_COMMIT_TAG}-1_amd64.deb)
      - [Pacman (Arch Linux)](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/remote-juggler-${CI_COMMIT_TAG}-1-x86_64.pkg.tar.zst)
      - [macOS PKG Installer (ARM64, Signed)](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-${CI_COMMIT_TAG}-darwin-arm64.pkg)
      - [macOS DMG Installer (ARM64, Notarized)](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/RemoteJuggler-${CI_COMMIT_TAG}-darwin-arm64.dmg)

      **GTK GUI (Linux):**
      - [GTK GUI (AMD64)](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-gui-linux-amd64)
      - [AppImage (AMD64)](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-gui-${CI_COMMIT_TAG}-x86_64.AppImage)

      **Tray Applications:**
      - [macOS Tray (ARM64)](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-tray-darwin-arm64)
      - [Linux Tray (AMD64)](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-tray-linux-amd64)

      ### Features

      - Multi-provider support (GitLab, GitHub, Bitbucket)
      - Darwin Keychain integration
      - GPG signing configuration
      - MCP server for Claude Code integration
      - ACP server for JetBrains IDE integration
    assets:
      links:
        - name: "${PROJECT_NAME}-linux-amd64"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-linux-amd64"
          filepath: "/binaries/${PROJECT_NAME}-linux-amd64"
          link_type: package
        - name: "${PROJECT_NAME}-darwin-arm64"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-darwin-arm64"
          filepath: "/binaries/${PROJECT_NAME}-darwin-arm64"
          link_type: package
        - name: "remote-juggler-rpm"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/remote-juggler-${CI_COMMIT_TAG}-1.x86_64.rpm"
          filepath: "/packages/remote-juggler.rpm"
          link_type: package
        - name: "remote-juggler-deb"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/remote-juggler_${CI_COMMIT_TAG}-1_amd64.deb"
          filepath: "/packages/remote-juggler.deb"
          link_type: package
        - name: "remote-juggler-darwin-pkg"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-${CI_COMMIT_TAG}-darwin-arm64.pkg"
          filepath: "/packages/remote-juggler-darwin.pkg"
          link_type: package
        - name: "remote-juggler-darwin-dmg"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/RemoteJuggler-${CI_COMMIT_TAG}-darwin-arm64.dmg"
          filepath: "/packages/RemoteJuggler-darwin.dmg"
          link_type: package
        - name: "${PROJECT_NAME}-tray-darwin-arm64"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-tray-darwin-arm64"
          filepath: "/tray/${PROJECT_NAME}-tray-darwin-arm64"
          link_type: package
        - name: "${PROJECT_NAME}-tray-linux-amd64"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-tray-linux-amd64"
          filepath: "/tray/${PROJECT_NAME}-tray-linux-amd64"
          link_type: package
        - name: "${PROJECT_NAME}-gui-linux-amd64"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-gui-linux-amd64"
          filepath: "/gui/${PROJECT_NAME}-gui-linux-amd64"
          link_type: package
        - name: "${PROJECT_NAME}-gui-appimage"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-gui-${CI_COMMIT_TAG}-x86_64.AppImage"
          filepath: "/gui/${PROJECT_NAME}-gui.AppImage"
          link_type: package

# =============================================================================
# Documentation Stage (MkDocs + llms.txt)
# =============================================================================

docs:build:
  stage: docs
  image: python:3.12-slim
  before_script:
    - pip install mkdocs mkdocs-material pymdown-extensions pyyaml
  script:
    # Generate snippets from source
    - mkdir -p docs/snippets
    - |
      if [ -f "${PROJECT_NAME}-linux-amd64" ]; then
        chmod +x ${PROJECT_NAME}-linux-amd64
        ./${PROJECT_NAME}-linux-amd64 --help > docs/snippets/cli-help.txt 2>/dev/null || echo "CLI help generation skipped"
        ./${PROJECT_NAME}-linux-amd64 list --help > docs/snippets/cli-list-help.txt 2>/dev/null || true
        ./${PROJECT_NAME}-linux-amd64 switch --help > docs/snippets/cli-switch-help.txt 2>/dev/null || true
      fi
    # Build MkDocs site (hooks will generate llms.txt)
    - mkdocs build --strict --verbose
    # Verify llms.txt was generated
    - |
      if [ -f "site/llms.txt" ]; then
        echo "llms.txt generated successfully ($(wc -c < site/llms.txt) bytes)"
      else
        echo "WARNING: llms.txt was not generated"
      fi
    - |
      if [ -f "site/llms-full.txt" ]; then
        echo "llms-full.txt generated successfully ($(wc -c < site/llms-full.txt) bytes)"
      else
        echo "WARNING: llms-full.txt was not generated"
      fi
  artifacts:
    paths:
      - site/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  needs:
    - job: build:linux-amd64
      optional: true

docs:linkcheck:
  stage: docs
  image: python:3.12-slim
  before_script:
    - pip install linkchecker
    - |
      # Install htmltest for internal link checking
      apt-get update && apt-get install -y curl
      ARCH=$(dpkg --print-architecture)
      if [ "$ARCH" = "amd64" ]; then
        curl -sL https://github.com/wjdp/htmltest/releases/download/v0.17.0/htmltest_0.17.0_linux_amd64.tar.gz | tar xz -C /usr/local/bin
      elif [ "$ARCH" = "arm64" ]; then
        curl -sL https://github.com/wjdp/htmltest/releases/download/v0.17.0/htmltest_0.17.0_linux_arm64.tar.gz | tar xz -C /usr/local/bin
      fi
  script:
    # Internal link check with htmltest (strict)
    - |
      if [ -f "docs/.htmltest.yml" ]; then
        htmltest site/ -c docs/.htmltest.yml || echo "htmltest found issues (non-blocking)"
      fi
    # External link check with linkchecker (allow failures)
    - linkchecker site/ --check-extern --ignore-url='localhost' --ignore-url='127.0.0.1' || true
  needs:
    - docs:build
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

docs:validate-llms:
  stage: docs
  image: python:3.12-slim
  script:
    # Validate llms.txt format
    - |
      python3 << 'EOF'
      import sys

      errors = []

      # Check llms.txt exists and has required structure
      try:
          with open('site/llms.txt') as f:
              content = f.read()

          if not content.startswith('# '):
              errors.append("llms.txt: Missing H1 title")
          if '> ' not in content:
              errors.append("llms.txt: Missing blockquote summary")
          if '## ' not in content:
              errors.append("llms.txt: Missing H2 sections")
          if '](http' not in content and '](/' not in content:
              errors.append("llms.txt: Missing links")

          print(f"llms.txt: {len(content)} bytes")
      except FileNotFoundError:
          errors.append("llms.txt: File not found")

      # Check llms-full.txt exists and size
      try:
          with open('site/llms-full.txt') as f:
              full_content = f.read()

          size = len(full_content)
          print(f"llms-full.txt: {size} bytes")

          if size > 102400:
              print(f"WARNING: llms-full.txt exceeds 100KB - may not fit in LLM context windows")
      except FileNotFoundError:
          errors.append("llms-full.txt: File not found")

      if errors:
          print("\nValidation errors:")
          for e in errors:
              print(f"  - {e}")
          sys.exit(1)

      print("\nllms.txt validation passed")
      EOF
  needs:
    - docs:build
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# =============================================================================
# FPM Packaging Stage
# =============================================================================

package:rpm:
  stage: package
  image: ruby:3.2-slim
  needs:
    - build:linux-amd64
  before_script:
    - apt-get update && apt-get install -y rpm
    - gem install fpm
  script:
    - mkdir -p pkg-root/usr/local/bin
    - cp ${PROJECT_NAME}-linux-amd64 pkg-root/usr/local/bin/remote-juggler
    - chmod +x pkg-root/usr/local/bin/remote-juggler
    - cp scripts/post-install.sh pkg-root/
    - cp scripts/pre-remove.sh pkg-root/
    - |
      fpm -s dir -t rpm \
        -n remote-juggler \
        -v ${CI_COMMIT_TAG:-0.0.0} \
        --iteration ${CI_PIPELINE_IID} \
        --architecture x86_64 \
        --vendor "Tinyland" \
        --maintainer "jess@tinyland.dev" \
        --url "https://gitlab.com/tinyland/projects/remote-juggler" \
        --description "Backend-agnostic git identity management with MCP/ACP support" \
        --license "MIT" \
        --depends "git" \
        --after-install pkg-root/post-install.sh \
        --before-remove pkg-root/pre-remove.sh \
        -C pkg-root \
        usr/local/bin/remote-juggler
  artifacts:
    paths:
      - "*.rpm"
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG

package:deb:
  stage: package
  image: ruby:3.2-slim
  needs:
    - build:linux-amd64
  before_script:
    - gem install fpm
  script:
    - mkdir -p pkg-root/usr/local/bin
    - cp ${PROJECT_NAME}-linux-amd64 pkg-root/usr/local/bin/remote-juggler
    - chmod +x pkg-root/usr/local/bin/remote-juggler
    - cp scripts/post-install.sh pkg-root/
    - cp scripts/pre-remove.sh pkg-root/
    - |
      fpm -s dir -t deb \
        -n remote-juggler \
        -v ${CI_COMMIT_TAG:-0.0.0} \
        --iteration ${CI_PIPELINE_IID} \
        --architecture amd64 \
        --vendor "Tinyland" \
        --maintainer "jess@tinyland.dev" \
        --url "https://gitlab.com/tinyland/projects/remote-juggler" \
        --description "Backend-agnostic git identity management with MCP/ACP support" \
        --license "MIT" \
        --depends "git" \
        --after-install pkg-root/post-install.sh \
        --before-remove pkg-root/pre-remove.sh \
        --deb-no-default-config-files \
        -C pkg-root \
        usr/local/bin/remote-juggler
  artifacts:
    paths:
      - "*.deb"
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG

package:pacman:
  stage: package
  image: archlinux:latest
  needs:
    - build:linux-amd64
  before_script:
    - pacman -Sy --noconfirm ruby
    - gem install fpm
  script:
    - mkdir -p pkg-root/usr/local/bin
    - cp ${PROJECT_NAME}-linux-amd64 pkg-root/usr/local/bin/remote-juggler
    - chmod +x pkg-root/usr/local/bin/remote-juggler
    - |
      fpm -s dir -t pacman \
        -n remote-juggler \
        -v ${CI_COMMIT_TAG:-0.0.0} \
        --architecture x86_64 \
        --maintainer "jess@tinyland.dev" \
        --description "Backend-agnostic git identity management with MCP/ACP support" \
        --license "MIT" \
        --depends "git" \
        -C pkg-root \
        usr/local/bin/remote-juggler
  artifacts:
    paths:
      - "*.pkg.tar.zst"
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG
  allow_failure: true  # pacman packaging may have compatibility issues

# =============================================================================
# macOS Code Signing Stage (Based on moonlight/sunshine patterns)
# =============================================================================

# Sign darwin binary with Developer ID Application certificate
sign:darwin-binary:
  stage: sign
  tags:
    - macos
    - arm64
  needs:
    - build:darwin-arm64
  variables:
    KEYCHAIN_NAME: "signing.keychain-db"
  script:
    - export VERSION=${CI_COMMIT_TAG:-0.0.0}
    - |
      if [ -n "$APPLE_CERTIFICATE_BASE64" ]; then
        echo "=== Setting up code signing ==="

        # Create temporary keychain with random password (moonlight pattern)
        KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"
        security delete-keychain "$KEYCHAIN_NAME" 2>/dev/null || true
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
        security set-keychain-settings "$KEYCHAIN_NAME"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
        security default-keychain -s "$KEYCHAIN_NAME"

        # Add login keychain and system roots to search list (sunshine pattern)
        LOGIN_KEYCHAIN="$HOME/Library/Keychains/login.keychain-db"
        security list-keychains -d user -s "$KEYCHAIN_NAME" "$LOGIN_KEYCHAIN" \
          /System/Library/Keychains/SystemRootCertificates.keychain

        # Import Developer ID G2 CA certificate for trust chain (sunshine pattern)
        if [ -n "$APPLE_DEVELOPER_ID_CA_G2" ]; then
          echo "Importing Developer ID G2 CA certificate..."
          echo "$APPLE_DEVELOPER_ID_CA_G2" | base64 -d > DeveloperIDG2CA.cer
          security import DeveloperIDG2CA.cer -k "$KEYCHAIN_NAME" \
            -T /usr/bin/codesign -T /usr/bin/productsign -A || true
          security import DeveloperIDG2CA.cer -k "$LOGIN_KEYCHAIN" -A || true
        fi

        # Import Developer ID Application certificate
        echo "Importing Developer ID Application certificate..."
        echo "$APPLE_CERTIFICATE_BASE64" | base64 -d > certificate.p12
        security import certificate.p12 -k "$KEYCHAIN_NAME" \
          -P "$APPLE_CERTIFICATE_PASSWORD" \
          -T /usr/bin/codesign -A

        # Set partition list for headless codesign access (critical for CI)
        security set-key-partition-list -S apple-tool:,apple: -s \
          -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

        # Sign the binary with hardened runtime (required for notarization)
        echo "Signing binary with hardened runtime..."
        codesign --force --options runtime --timestamp \
          --sign "$APPLE_DEVELOPER_ID_APPLICATION" \
          --keychain "$KEYCHAIN_NAME" \
          ${PROJECT_NAME}-darwin-arm64

        # Verify signature
        echo "Verifying binary signature..."
        codesign --verify --verbose=4 ${PROJECT_NAME}-darwin-arm64
        spctl --assess --type execute --verbose=4 ${PROJECT_NAME}-darwin-arm64 || true

        echo "Binary signing complete"

        # Cleanup sensitive files
        rm -f certificate.p12 DeveloperIDG2CA.cer
      else
        echo "No signing certificate - binary will be unsigned"
      fi

    # Generate SHA256 checksum
    - shasum -a 256 ${PROJECT_NAME}-darwin-arm64 > ${PROJECT_NAME}-darwin-arm64.sha256

  artifacts:
    paths:
      - ${PROJECT_NAME}-darwin-arm64
      - ${PROJECT_NAME}-darwin-arm64.sha256
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG
  allow_failure: true

# Sign darwin PKG installer with Developer ID Installer certificate
sign:darwin-pkg:
  stage: sign
  tags:
    - macos
    - arm64
  needs:
    - sign:darwin-binary
  variables:
    KEYCHAIN_NAME: "signing.keychain-db"
  script:
    - export VERSION=${CI_COMMIT_TAG:-0.0.0}
    - |
      if [ -n "$APPLE_CERTIFICATE_BASE64" ]; then
        echo "=== Setting up PKG signing ==="

        # Create temporary keychain with random password
        KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"
        security delete-keychain "$KEYCHAIN_NAME" 2>/dev/null || true
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
        security set-keychain-settings "$KEYCHAIN_NAME"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
        security default-keychain -s "$KEYCHAIN_NAME"

        # Add login keychain and system roots to search list
        LOGIN_KEYCHAIN="$HOME/Library/Keychains/login.keychain-db"
        security list-keychains -d user -s "$KEYCHAIN_NAME" "$LOGIN_KEYCHAIN" \
          /System/Library/Keychains/SystemRootCertificates.keychain

        # Import Developer ID G2 CA certificate
        if [ -n "$APPLE_DEVELOPER_ID_CA_G2" ]; then
          echo "Importing Developer ID G2 CA certificate..."
          echo "$APPLE_DEVELOPER_ID_CA_G2" | base64 -d > DeveloperIDG2CA.cer
          security import DeveloperIDG2CA.cer -k "$KEYCHAIN_NAME" \
            -T /usr/bin/codesign -T /usr/bin/productsign -A || true
        fi

        # Import Developer ID Installer certificate (for PKG signing)
        # Falls back to Application certificate password if Installer password not set
        if [ -n "$APPLE_INSTALLER_CERTIFICATE_BASE64" ]; then
          echo "Importing Developer ID Installer certificate..."
          echo "$APPLE_INSTALLER_CERTIFICATE_BASE64" | base64 -d > installer_certificate.p12
          INSTALLER_PWD="${APPLE_INSTALLER_CERTIFICATE_PASSWORD:-$APPLE_CERTIFICATE_PASSWORD}"
          if ! security import installer_certificate.p12 -k "$KEYCHAIN_NAME" \
            -P "$INSTALLER_PWD" -T /usr/bin/productsign -A; then
            echo "WARNING: Installer certificate import failed"
          fi
        else
          # Use Application certificate for PKG signing if no Installer cert
          echo "Importing Application certificate for PKG signing..."
          echo "$APPLE_CERTIFICATE_BASE64" | base64 -d > certificate.p12
          security import certificate.p12 -k "$KEYCHAIN_NAME" \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/productsign -A
        fi

        # Set partition list for headless access
        security set-key-partition-list -S apple-tool:,apple: -s \
          -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

        # Create PKG installer structure
        echo "Creating PKG structure..."
        mkdir -p pkg-root/usr/local/bin
        cp ${PROJECT_NAME}-darwin-arm64 pkg-root/usr/local/bin/remote-juggler
        chmod +x pkg-root/usr/local/bin/remote-juggler

        # Build unsigned PKG first
        echo "Building unsigned PKG..."
        pkgbuild --root pkg-root \
          --identifier "dev.tinyland.remote-juggler" \
          --version "$VERSION" \
          --install-location "/" \
          ${PROJECT_NAME}-${VERSION}-unsigned.pkg

        # Sign PKG with productsign
        PKG_SIGNED=false
        if [ -n "$APPLE_DEVELOPER_ID_INSTALLER" ]; then
          echo "Signing PKG with Developer ID Installer..."
          if productsign --sign "$APPLE_DEVELOPER_ID_INSTALLER" \
            --keychain "$KEYCHAIN_NAME" \
            ${PROJECT_NAME}-${VERSION}-unsigned.pkg \
            ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg; then
            rm ${PROJECT_NAME}-${VERSION}-unsigned.pkg
            PKG_SIGNED=true

            # Verify PKG signature
            echo "Verifying PKG signature..."
            pkgutil --check-signature ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg
            spctl --assess --type install --verbose=4 ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg || true

            # Notarize if credentials provided
            if [ -n "$APPLE_ID" ] && [ -n "$APPLE_NOTARIZE_PASSWORD" ] && [ -n "$APPLE_TEAM_ID" ]; then
              echo "Submitting for notarization..."
              SUBMISSION_OUTPUT=$(xcrun notarytool submit ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_NOTARIZE_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" \
                --wait 2>&1) || true

              echo "$SUBMISSION_OUTPUT"

              # Check for failure and save log if needed
              if echo "$SUBMISSION_OUTPUT" | grep -q "status: Invalid"; then
                SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
                if [ -n "$SUBMISSION_ID" ]; then
                  echo "Fetching notarization log..."
                  xcrun notarytool log "$SUBMISSION_ID" \
                    --apple-id "$APPLE_ID" \
                    --password "$APPLE_NOTARIZE_PASSWORD" \
                    --team-id "$APPLE_TEAM_ID" > notarization-log.json || true
                fi
                echo "WARNING: Notarization failed - see notarization-log.json"
              else
                # Staple notarization ticket
                echo "Stapling notarization ticket..."
                xcrun stapler staple ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg || \
                  echo "WARNING: Stapling failed"

                # Validate stapled PKG
                echo "Validating stapled PKG..."
                xcrun stapler validate ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg || true
              fi
            else
              echo "Notarization skipped - credentials not provided"
            fi
          else
            echo "WARNING: PKG signing failed"
          fi
        fi

        # Fall back to unsigned package if signing wasn't attempted or failed
        if [ "$PKG_SIGNED" = "false" ]; then
          echo "Using unsigned package..."
          mv ${PROJECT_NAME}-${VERSION}-unsigned.pkg ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg || true
        fi

        # Cleanup sensitive files
        rm -f certificate.p12 installer_certificate.p12 DeveloperIDG2CA.cer
        security delete-keychain "$KEYCHAIN_NAME" 2>/dev/null || true

        echo "PKG signing complete (signed=$PKG_SIGNED)"
      else
        echo "No signing certificate - creating unsigned PKG"
        mkdir -p pkg-root/usr/local/bin
        cp ${PROJECT_NAME}-darwin-arm64 pkg-root/usr/local/bin/remote-juggler
        chmod +x pkg-root/usr/local/bin/remote-juggler
        pkgbuild --root pkg-root \
          --identifier "dev.tinyland.remote-juggler" \
          --version "$VERSION" \
          --install-location "/" \
          ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg
      fi

    # Generate SHA256 checksum
    - shasum -a 256 ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg > ${PROJECT_NAME}-${VERSION}-darwin-arm64.pkg.sha256 || true

  artifacts:
    paths:
      - "*.pkg"
      - "*.pkg.sha256"
      - notarization-log.json
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_COMMIT_TAG
  allow_failure: true

# Create signed and notarized DMG installer
release:dmg:
  stage: release
  tags:
    - macos
    - arm64
  needs:
    - sign:darwin-binary
    - job: build:tray-darwin
      optional: true
  variables:
    KEYCHAIN_NAME: "signing.keychain-db"
  script:
    - export VERSION=${CI_COMMIT_TAG:-0.0.0}
    - |
      # Copy tray binary to build dir for bundling if available
      if [ -f "${PROJECT_NAME}-tray-darwin-arm64" ]; then
        mkdir -p build
        cp ${PROJECT_NAME}-tray-darwin-arm64 build/RemoteJugglerTray
        chmod +x build/RemoteJugglerTray
      fi

    - |
      if [ -n "$APPLE_CERTIFICATE_BASE64" ]; then
        echo "=== Setting up DMG signing ==="

        # Create temporary keychain
        KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"
        security delete-keychain "$KEYCHAIN_NAME" 2>/dev/null || true
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
        security set-keychain-settings "$KEYCHAIN_NAME"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
        security default-keychain -s "$KEYCHAIN_NAME"

        # Add keychains to search list
        LOGIN_KEYCHAIN="$HOME/Library/Keychains/login.keychain-db"
        security list-keychains -d user -s "$KEYCHAIN_NAME" "$LOGIN_KEYCHAIN" \
          /System/Library/Keychains/SystemRootCertificates.keychain

        # Import G2 CA certificate
        if [ -n "$APPLE_DEVELOPER_ID_CA_G2" ]; then
          echo "$APPLE_DEVELOPER_ID_CA_G2" | base64 -d > DeveloperIDG2CA.cer
          security import DeveloperIDG2CA.cer -k "$KEYCHAIN_NAME" \
            -T /usr/bin/codesign -A || true
        fi

        # Import Developer ID Application certificate
        echo "$APPLE_CERTIFICATE_BASE64" | base64 -d > certificate.p12
        security import certificate.p12 -k "$KEYCHAIN_NAME" \
          -P "$APPLE_CERTIFICATE_PASSWORD" \
          -T /usr/bin/codesign -A

        # Set partition list
        security set-key-partition-list -S apple-tool:,apple: -s \
          -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

        # Set signing identity for create-dmg.sh
        export SIGNING_IDENTITY_APP="$APPLE_DEVELOPER_ID_APPLICATION"
        export KEYCHAIN_PATH="$KEYCHAIN_NAME"
      fi

    # Run the DMG creation script
    - chmod +x scripts/create-dmg.sh scripts/create-app-bundle.sh
    - ./scripts/create-dmg.sh "$VERSION"

    - |
      DMG_FILE="RemoteJuggler-${VERSION}-darwin-arm64.dmg"
      if [ -f "build/$DMG_FILE" ]; then
        cp "build/$DMG_FILE" .
        cp "build/${DMG_FILE}.sha256" . 2>/dev/null || shasum -a 256 "$DMG_FILE" > "${DMG_FILE}.sha256"

        # Notarize if credentials provided
        if [ -n "$APPLE_ID" ] && [ -n "$APPLE_NOTARIZE_PASSWORD" ] && [ -n "$APPLE_TEAM_ID" ]; then
          echo "Submitting DMG for notarization..."
          SUBMISSION_OUTPUT=$(xcrun notarytool submit "$DMG_FILE" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_NOTARIZE_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait 2>&1) || true

          echo "$SUBMISSION_OUTPUT"

          if echo "$SUBMISSION_OUTPUT" | grep -q "status: Accepted"; then
            echo "Stapling notarization ticket..."
            xcrun stapler staple "$DMG_FILE"
            xcrun stapler validate "$DMG_FILE"
            # Regenerate checksum after stapling
            shasum -a 256 "$DMG_FILE" > "${DMG_FILE}.sha256"
          else
            echo "WARNING: Notarization may have failed - check output above"
          fi
        fi
      fi

    # Cleanup
    - rm -f certificate.p12 DeveloperIDG2CA.cer
    - security delete-keychain "$KEYCHAIN_NAME" 2>/dev/null || true

  artifacts:
    paths:
      - "*.dmg"
      - "*.dmg.sha256"
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG
  allow_failure: true

# =============================================================================
# GitLab Pages Deployment
# =============================================================================

# =============================================================================
# Homebrew Tap Update
# =============================================================================

release:homebrew-tap:
  stage: release
  image: alpine:3.19
  needs:
    - release:package
  variables:
    HOMEBREW_TAP_REPO: "https://gitlab.com/tinyland/homebrew-tools.git"
    FORMULA_PATH: "Formula/remote-juggler.rb"
  before_script:
    - apk add --no-cache git curl bash openssh-client
  script:
    - export VERSION="${CI_COMMIT_TAG#v}"
    - |
      echo "=== Updating Homebrew tap for version ${VERSION} ==="

      # Configure git
      git config --global user.email "ci@tinyland.dev"
      git config --global user.name "Tinyland CI"

      # Clone tap repo
      git clone "https://oauth2:${HOMEBREW_TAP_TOKEN}@gitlab.com/tinyland/homebrew-tools.git" homebrew-tap
      cd homebrew-tap

      # Download binaries and compute checksums
      echo "Computing checksums..."
      DARWIN_ARM64_SHA=""
      DARWIN_AMD64_SHA=""
      LINUX_AMD64_SHA=""
      LINUX_ARM64_SHA=""

      # Darwin ARM64
      if curl -fsSL -o /tmp/darwin-arm64.tar.gz \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-darwin-arm64"; then
        DARWIN_ARM64_SHA=$(sha256sum /tmp/darwin-arm64.tar.gz | cut -d' ' -f1)
        echo "Darwin ARM64: ${DARWIN_ARM64_SHA}"
      fi

      # Darwin AMD64
      if curl -fsSL -o /tmp/darwin-amd64.tar.gz \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-darwin-amd64"; then
        DARWIN_AMD64_SHA=$(sha256sum /tmp/darwin-amd64.tar.gz | cut -d' ' -f1)
        echo "Darwin AMD64: ${DARWIN_AMD64_SHA}"
      fi

      # Linux AMD64
      if curl -fsSL -o /tmp/linux-amd64.tar.gz \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-linux-amd64"; then
        LINUX_AMD64_SHA=$(sha256sum /tmp/linux-amd64.tar.gz | cut -d' ' -f1)
        echo "Linux AMD64: ${LINUX_AMD64_SHA}"
      fi

      # Linux ARM64
      if curl -fsSL -o /tmp/linux-arm64.tar.gz \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PROJECT_NAME}/${CI_COMMIT_TAG}/${PROJECT_NAME}-linux-arm64"; then
        LINUX_ARM64_SHA=$(sha256sum /tmp/linux-arm64.tar.gz | cut -d' ' -f1)
        echo "Linux ARM64: ${LINUX_ARM64_SHA}"
      fi

      # Update formula
      echo "Updating formula..."

      # Update version
      sed -i "s/version \"[^\"]*\"/version \"${VERSION}\"/" "${FORMULA_PATH}"

      # Update URLs (from v1.0.0 to current tag)
      sed -i "s|/releases/v[^/]*/downloads/|/releases/${CI_COMMIT_TAG}/downloads/|g" "${FORMULA_PATH}"

      # Update checksums
      if [ -n "$DARWIN_ARM64_SHA" ]; then
        sed -i "s/sha256 \"[^\"]*\" # darwin-arm64/sha256 \"${DARWIN_ARM64_SHA}\" # darwin-arm64/" "${FORMULA_PATH}"
      fi
      if [ -n "$DARWIN_AMD64_SHA" ]; then
        sed -i "s/sha256 \"[^\"]*\" # darwin-amd64/sha256 \"${DARWIN_AMD64_SHA}\" # darwin-amd64/" "${FORMULA_PATH}"
      fi
      if [ -n "$LINUX_AMD64_SHA" ]; then
        sed -i "s/sha256 \"[^\"]*\" # linux-amd64/sha256 \"${LINUX_AMD64_SHA}\" # linux-amd64/" "${FORMULA_PATH}"
      fi
      if [ -n "$LINUX_ARM64_SHA" ]; then
        sed -i "s/sha256 \"[^\"]*\" # linux-arm64/sha256 \"${LINUX_ARM64_SHA}\" # linux-arm64/" "${FORMULA_PATH}"
      fi

      # Show diff
      git diff "${FORMULA_PATH}"

      # Commit and push
      git add "${FORMULA_PATH}"
      if git diff --staged --quiet; then
        echo "No changes to commit"
      else
        git commit -m "Bump remote-juggler to ${VERSION}"
        git push origin main
        echo "Homebrew tap updated successfully"
      fi
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/
  allow_failure: true

# =============================================================================
# GitLab Pages Deployment
# =============================================================================

pages:
  stage: release
  needs:
    - docs:build
  script:
    - mv site public
  artifacts:
    paths:
      - public
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# OutBot Sync Stage (GitLab  GitHub Mirror)
# =============================================================================

# Scheduled sync - runs every 15 minutes
outbot:sync:scheduled:
  stage: sync
  image:
    name: registry.gitlab.com/tinyland/ai/outbot-ci:latest
    pull_policy: always
  variables:
    GIT_DEPTH: 0
    GIT_STRATEGY: clone
  script:
    - outbot sync --config .outbot.yml
  timeout: 5 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - job_execution_timeout
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: always

# Push-triggered sync - manual for main branch
outbot:sync:
  stage: sync
  image:
    name: registry.gitlab.com/tinyland/ai/outbot-ci:latest
    pull_policy: always
  variables:
    GIT_DEPTH: 0
    GIT_STRATEGY: clone
  script:
    - outbot sync --config .outbot.yml
  timeout: 5 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - job_execution_timeout
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: true

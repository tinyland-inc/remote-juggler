# Auto-apply OpenTofu after image tag changes in terraform.tfvars.
#
# Triggers on pushes to main that modify terraform.tfvars (e.g., Renovate
# merging container image bumps). All secrets are injected as GitHub Actions
# secrets — no gateway port-forward needed (Setec uses tailnet URLs not
# reachable from CI runners).
#
# This closes the last manual step in the deployment pipeline:
#   GHCR build → Renovate PR → automerge → tofu apply (this workflow)
name: Tofu Auto-Apply

on:
  push:
    branches: [main]
    paths:
      - 'deploy/tofu/terraform.tfvars'
      - 'deploy/tofu/*.tf'
  workflow_dispatch:

# Only one apply at a time.
concurrency:
  group: tofu-apply
  cancel-in-progress: false

jobs:
  apply:
    runs-on: ubuntu-latest
    # Skip if the commit is from this workflow (prevent loops).
    if: "!contains(github.event.head_commit.message, '[skip-tofu]')"
    steps:
      - uses: actions/checkout@v4

      - name: Install OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: '1.9.0'

      - name: Install Civo CLI
        run: |
          curl -sL https://civo.com/get | sh
          echo "/usr/local/bin" >> "$GITHUB_PATH"

      - name: Configure kubeconfig
        env:
          CIVO_TOKEN: ${{ secrets.CIVO_TOKEN }}
        run: |
          mkdir -p ~/.kube
          civo kubernetes config tinyland-civo-dev --save
          echo "KUBECONFIG=$HOME/.kube/config" >> "$GITHUB_ENV"

      - name: Init + Apply
        working-directory: deploy/tofu
        env:
          # All secrets injected as env vars. apply.sh resolve_or_env() uses
          # these directly, falling back to gateway only for secrets not in env.
          TF_VAR_tailscale_oauth_client_id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          TF_VAR_tailscale_oauth_client_secret: ${{ secrets.TAILSCALE_OAUTH_CLIENT_SECRET }}
          TF_VAR_tailscale_auth_key: ${{ secrets.TAILSCALE_AUTH_KEY }}
          TF_VAR_civo_token: ${{ secrets.CIVO_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.CIVO_S3_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.CIVO_S3_SECRET_KEY }}
          TF_VAR_aperture_s3_access_key: ${{ secrets.FUZZY_MODELS_S3_KEY }}
          TF_VAR_aperture_s3_secret_key: ${{ secrets.FUZZY_MODELS_S3_SECRET }}
          TF_VAR_ghcr_token: ${{ secrets.GHCR_TOKEN }}
          TF_VAR_github_token: ${{ secrets.RJ_GITHUB_TOKEN }}
          TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          TF_VAR_github_app_private_key: ${{ secrets.RJ_APP_PRIVATE_KEY }}
        run: |
          # Init with S3 backend creds directly (apply.sh can't init without them).
          tofu init -input=false \
            -backend-config="access_key=$AWS_ACCESS_KEY_ID" \
            -backend-config="secret_key=$AWS_SECRET_ACCESS_KEY"
          # Remove stale setec-seed job from state if it was cleaned up by
          # K8s TTL (ttl_seconds_after_finished=300). Without this, tofu
          # errors with "job is not in complete state" on re-apply.
          tofu state rm 'kubernetes_job.setec_seed[0]' 2>/dev/null || true
          # apply.sh resolve_or_env() skips gateway for secrets in env.
          # Optional secrets (gitlab_token, brave_api_key, SSH keys) default
          # to empty string when not in env and gateway is unreachable.
          ./apply.sh apply -auto-approve

      - name: Verify pods healthy
        run: |
          echo "Waiting 30s for rollout..."
          sleep 30
          kubectl get pods -n fuzzy-dev \
            -l 'app in (rj-gateway,ironclaw-agent,picoclaw-agent,hexstrike-ai-agent,setec)' \
            -o wide
          # Check all pods are Running.
          NOT_RUNNING=$(kubectl get pods -n fuzzy-dev \
            -l 'app in (rj-gateway,ironclaw-agent,picoclaw-agent,hexstrike-ai-agent,setec)' \
            -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}')
          if [ -n "$NOT_RUNNING" ]; then
            echo "::error::Pods not running: $NOT_RUNNING"
            exit 1
          fi
          echo "All pods healthy"

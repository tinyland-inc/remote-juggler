#!/usr/bin/env bash
#
# RemoteJuggler README Artifact Block Generator
#
# Fetches release metadata from GitHub and generates a comprehensive
# artifact info block for README.md between marker comments.
#
# Usage:
#   ./scripts/update-readme-artifacts.sh [options]
#
# Options:
#   --tag TAG       Specific release tag (default: most recent release)
#   --readme FILE   Path to README.md (default: ./README.md)
#   --dry-run       Print generated block to stdout, don't modify README
#   --help          Show this help
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

REPO="Jesssullivan/RemoteJuggler"
MARKER_START="<!-- ARTIFACT-TABLE:START -->"
MARKER_END="<!-- ARTIFACT-TABLE:END -->"
DOWNLOAD_BASE="https://github.com/${REPO}/releases/download"
RELEASE_URL="https://github.com/${REPO}/releases"

# Toolchain versions (keep in sync with release.yml)
CHAPEL_VERSION="2.7.0"
GO_VERSION="1.21"
RUST_TOOLCHAIN="stable"

# Defaults
TAG=""
README="${PROJECT_ROOT}/README.md"
DRY_RUN=false

usage() {
    sed -n '3,16p' "$0" | sed 's/^# \?//'
    exit 0
}

log() { echo "==> $*" >&2; }
err() { echo "ERROR: $*" >&2; exit 1; }

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --tag)    TAG="$2"; shift 2 ;;
        --readme) README="$2"; shift 2 ;;
        --dry-run) DRY_RUN=true; shift ;;
        --help)   usage ;;
        *)        err "Unknown option: $1" ;;
    esac
done

# Verify prerequisites
command -v gh >/dev/null 2>&1 || err "gh CLI required but not found"
command -v jq >/dev/null 2>&1 || err "jq required but not found"

# Find latest release tag (including pre-releases)
if [ -z "$TAG" ]; then
    TAG=$(gh api "repos/${REPO}/releases" --jq '.[0].tag_name' 2>/dev/null || echo "")
    [ -n "$TAG" ] || err "No releases found for ${REPO}"
fi
log "Using release: ${TAG}"

# Fetch release metadata
RELEASE_JSON=$(gh api "repos/${REPO}/releases/tags/${TAG}" 2>/dev/null) \
    || err "Failed to fetch release ${TAG}"

RELEASE_DATE=$(echo "$RELEASE_JSON" | jq -r '.published_at | split("T")[0]')
PRERELEASE=$(echo "$RELEASE_JSON" | jq -r '.prerelease')
RELEASE_NOTES_URL="${RELEASE_URL}/tag/${TAG}"

# Fetch SHA256SUMS.txt from release assets
CHECKSUMS_URL="${DOWNLOAD_BASE}/${TAG}/SHA256SUMS.txt"
CHECKSUMS=$(curl -fsSL "$CHECKSUMS_URL" 2>/dev/null || echo "")

# --- Helper functions ---

human_size() {
    local bytes="$1"
    if [ "$bytes" -ge 1048576 ]; then
        awk "BEGIN {printf \"%.1fMB\", $bytes/1048576}"
    elif [ "$bytes" -ge 1024 ]; then
        awk "BEGIN {printf \"%.0fKB\", $bytes/1024}"
    else
        echo "${bytes}B"
    fi
}

# Get download link for an exact asset name, or "--" if missing
download_cell() {
    local name="$1"
    local info
    info=$(echo "$RELEASE_JSON" | jq -r \
        --arg name "$name" \
        '.assets[] | select(.name == $name) | "\(.size)\t\(.browser_download_url)"')
    if [ -z "$info" ]; then
        echo "--"
    else
        local size url
        size=$(echo "$info" | cut -f1)
        url=$(echo "$info" | cut -f2)
        echo "[${name}](${url}) ($(human_size "$size"))"
    fi
}

# Find an asset matching a regex pattern (for version-dependent names like .deb, .rpm, .AppImage)
# Returns "name\tsize\turl" or empty
find_asset() {
    local pattern="$1"
    echo "$RELEASE_JSON" | jq -r \
        --arg pat "$pattern" \
        '[.assets[] | select(.name | test($pat)) | select(.name | test("\\.sha256$") | not)] | .[0] // empty | "\(.name)\t\(.size)\t\(.browser_download_url)"'
}

# Build a download cell from a regex pattern match
download_cell_pattern() {
    local pattern="$1"
    local info
    info=$(find_asset "$pattern")
    if [ -z "$info" ]; then
        echo "--"
    else
        local name size url
        name=$(echo "$info" | cut -f1)
        size=$(echo "$info" | cut -f2)
        url=$(echo "$info" | cut -f3)
        echo "[${name}](${url}) ($(human_size "$size"))"
    fi
}

# --- Generate markdown ---

generate_block() {
    local prerelease_label=""
    if [ "$PRERELEASE" = "true" ]; then
        prerelease_label=" (pre-release)"
    fi

    cat <<BLOCK
<!-- Auto-generated by scripts/update-readme-artifacts.sh -- do not edit manually -->

### Latest Release

**${TAG}**${prerelease_label} | ${RELEASE_DATE} | [Release Notes](${RELEASE_NOTES_URL}) | [All Releases](${RELEASE_URL})

### Binary Downloads

| Platform | CLI | GTK GUI | Tray |
|----------|-----|---------|------|
| Linux x86_64 | $(download_cell "remote-juggler-linux-amd64") | $(download_cell "remote-juggler-gui-linux-amd64") | $(download_cell "remote-juggler-tray-linux-amd64") |
| Linux ARM64 | $(download_cell "remote-juggler-linux-arm64") | $(download_cell "remote-juggler-gui-linux-arm64") | $(download_cell "remote-juggler-tray-linux-arm64") |
| macOS ARM64 | $(download_cell "remote-juggler-darwin-arm64") | -- | $(download_cell "remote-juggler-tray-darwin-arm64") |
| macOS x86_64 | $(download_cell "remote-juggler-darwin-amd64") | -- | -- |

### Packages

| Format | File | Size |
|--------|------|------|
| Debian/Ubuntu | $(download_cell_pattern "^remote-juggler_.*\\.deb$") |
| RHEL/Fedora | $(download_cell_pattern "^remote-juggler-.*\\.rpm$") |
| AppImage | $(download_cell_pattern "^remote-juggler-gui-.*\\.AppImage$") |
| Docker | \`ghcr.io/jesssullivan/remote-juggler:latest\` |
| npm | \`npx @tummycrypt/remote-juggler@latest\` |
| Homebrew | \`brew install remote-juggler\` |
| Nix | \`nix profile install github:Jesssullivan/RemoteJuggler\` |

### Platform Compatibility

| Feature | Linux x86_64 | Linux ARM64 | macOS ARM64 | macOS x86_64 |
|---------|:---:|:---:|:---:|:---:|
| CLI + MCP/ACP | Y | Y | Y | Y |
| GTK GUI | Y | Y | -- | -- |
| System Tray | Y | Y | Y | -- |
| KeePassXC | Y | Y | Y | Y |
| YubiKey/FIDO2 | Y | Y | Y | Y |
| Docker | Y | -- | -- | -- |
BLOCK

    # SHA256 checksums (collapsible)
    if [ -n "$CHECKSUMS" ]; then
        cat <<CHECKSUMS_BLOCK

<details>
<summary>SHA256 Checksums</summary>

\`\`\`
${CHECKSUMS}
\`\`\`

Full checksums file: [SHA256SUMS.txt](${DOWNLOAD_BASE}/${TAG}/SHA256SUMS.txt)

</details>
CHECKSUMS_BLOCK
    fi

    # Build toolchain (collapsible)
    cat <<TOOLCHAIN

<details>
<summary>Build Toolchain</summary>

| Component | Toolchain | Version |
|-----------|-----------|---------|
| CLI | Chapel | ${CHAPEL_VERSION} |
| GTK GUI | Rust | ${RUST_TOOLCHAIN} |
| Tray (Linux) | Go | ${GO_VERSION} |
| Tray (macOS) | Swift | 6.0 |

</details>

> **Note:** macOS binaries from GitHub are unsigned. For signed/notarized macOS builds, see [GitLab Releases](https://gitlab.com/tinyland/projects/remote-juggler/-/releases).
TOOLCHAIN
}

# --- Splice into README ---

splice_into_readme() {
    local readme="$1"
    local content_file="$2"

    # Verify markers exist
    grep -q "$MARKER_START" "$readme" || err "Marker ${MARKER_START} not found in ${readme}"
    grep -q "$MARKER_END" "$readme" || err "Marker ${MARKER_END} not found in ${readme}"

    local before after tmpfile
    tmpfile=$(mktemp)

    # Extract content before start marker (inclusive)
    before=$(awk "/${MARKER_START}/{print; exit} {print}" "$readme")
    # Extract content after end marker (inclusive)
    after=$(awk "found {print} /${MARKER_END}/{found=1}" "$readme")

    {
        echo "$before"
        cat "$content_file"
        echo "$MARKER_END"
        echo "$after"
    } > "$tmpfile"

    mv "$tmpfile" "$readme"
    log "Updated ${readme}"
}

# --- Main ---

CONTENT_FILE=$(mktemp)
generate_block > "$CONTENT_FILE"

if [ "$DRY_RUN" = true ]; then
    echo "$MARKER_START"
    cat "$CONTENT_FILE"
    echo "$MARKER_END"
    rm -f "$CONTENT_FILE"
else
    splice_into_readme "$README" "$CONTENT_FILE"
    rm -f "$CONTENT_FILE"
fi

log "Done."
